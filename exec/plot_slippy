#!/usr/bin/env python
import os
import argparse
import slippy.bm
import slippy.xyz2geo
import slippy.patch
import slippy.io
import slippy.quiver
import numpy as np
import matplotlib.pyplot as plt
import subprocess

QUIVER_SCALE = 0.00001
QUIVER_KEY_LENGTH = 1.0
QUIVER_KEY_POS_X = 0.7
QUIVER_KEY_POS_Y = 0.1

def draw_grid(bm,spacing=1.0,**kwargs):
  bm.drawmeridians(np.arange(np.floor(bm.llcrnrlon),
                     np.ceil(bm.urcrnrlon),spacing),
                     labels=[0,0,0,1],
                     **kwargs)
  bm.drawparallels(np.arange(np.floor(bm.llcrnrlat),
                     np.ceil(bm.urcrnrlat),spacing),
                     labels=[1,0,0,0],
                     **kwargs)
  return


p = argparse.ArgumentParser(
      description='''Plots the results of SlipPy''')
      
p.add_argument('--observed_gps_file',type=str)
p.add_argument('--predicted_gps_file',type=str)
p.add_argument('--observed_insar_file',type=str)
p.add_argument('--predicted_insar_file',type=str)
p.add_argument('--slip_output_file',type=str)
p.add_argument('--plotter',type=str, default='basemap')
config = vars(p.parse_args())

bm = None

# Make a map of strike slip, thrust slip, and tensile slip
if config['slip_output_file'] is not None:
  input = slippy.io.read_slip_data(config['slip_output_file'])
  patch_pos_geo = input[0]
  
  if config['plotter']=='gmt':
    bm = slippy.xyz2geo.create_default_basemap(patch_pos_geo[:,0],patch_pos_geo[:,1],resolution='i')
    pos_cart = slippy.xyz2geo.geodetic_to_cartesian(patch_pos_geo,bm)
  else:
    bm = slippy.bm.create_default_basemap(patch_pos_geo[:,0],patch_pos_geo[:,1],resolution='i')
    pos_cart = slippy.bm.geodetic_to_cartesian(patch_pos_geo,bm)

  strike = input[1]
  dip = input[2]
  length = input[3]
  width = input[4]
  slip = input[5]
  patches = [slippy.patch.Patch(p,l,w,s,d) for p,l,w,s,d in zip(pos_cart,
                                                                length,width,
                                                                strike,dip)]

  titles = ['left-lateral slip','thrust slip','tensile slip']

  if config['plotter']=='gmt': # run gmt plotting  
    xy_geo_array=[]
    for p in patches:  # put the patch vertices into geodetic coordinates
      polys=p.get_polygon()
      xy_cart=polys.get_xy()
      xy_geo = slippy.xyz2geo.cartesian_to_geodetic(xy_cart,bm)
      xy_geo_array.append(xy_geo)

    for i in range(3):  # write the patches
      slippy.patch.write_patches_geo(xy_geo_array, slip[:,i],config['slip_output_file']+'_gmt')  # a plain text format
      cmin=min(slip[:,i])
      cmax=max(slip[:,i])
      cntv=(cmax-cmin)/20
      if (cmax-cmin)<0.001:
        cmin=-1
        cmax=1
        cntv=0.05
      title=titles[i].split()[0] 
      command = "gmt_plot.sh "+config['slip_output_file']+"_gmt "+title+ " "+str(bm.llcrnrlon)+" "+str(bm.llcrnrlat)+" "+str(bm.urcrnrlon)+" "+str(bm.urcrnrlat)+" "+bm.proj+" "+str(cmin)+" "+str(cmax)+" "+str(cntv)+" "+config['observed_gps_file']+" "+config['predicted_gps_file'];
      print(command);
      subprocess.call(['gmt_plot.sh',config['slip_output_file']+'_gmt',title,str(bm.llcrnrlon), str(bm.llcrnrlat), 
        str(bm.urcrnrlon), str(bm.urcrnrlat), bm.proj, str(cmin), str(cmax), str(cntv),config['observed_gps_file'],config['predicted_gps_file']],shell=False);

  else:  # run python plotting
    for i in range(3):
      fig,ax = plt.subplots()
      ax.set_title(titles[i]) 
      bm.drawstates(ax=ax)
      bm.drawcountries(ax=ax)
      bm.drawcoastlines(ax=ax)
      ps = slippy.patch.draw_patches(patches,colors=slip[:,i],ax=ax,edgecolor='none',zorder=0,cmap='viridis')
      draw_grid(bm,ax=ax,dashes=[3,3])
      cbar = fig.colorbar(ps,ax=ax)
      cbar.set_label('meters')
      plt.savefig(titles[i]+".jpg"); 

### NEW FIGURE
bm = None
key_drawn = False
segment_drawn = False
if (config['observed_gps_file'] is not None) | (config['predicted_gps_file'] is not None):

  if config['plotter']=='gmt':
    if config['observed_gps_file'] is not None:
      pos_geo,disp,sigma = slippy.io.read_gps_data(config['observed_gps_file'])
      slippy.io.write_gps_data(pos_geo,disp,sigma,'observed_gps.txt_gmt')
    if config['predicted_gps_file'] is not None:
      pos_geo,disp,sigma = slippy.io.read_gps_data(config['predicted_gps_file'])
      slippy.io.write_gps_data(pos_geo,disp,sigma,'predicted_gps.txt_gmt')
    bm = slippy.xyz2geo.create_default_basemap(pos_geo[:,0],pos_geo[:,1],resolution='i')
    subprocess.call(['quiver_plot.sh','predicted_gps.txt_gmt','observed_gps.txt_gmt',
      str(bm.llcrnrlon), str(bm.llcrnrlat), str(bm.urcrnrlon), str(bm.urcrnrlat), bm.proj],shell=False); 

  else:

    fig,ax = plt.subplots()
    ax.set_title('GPS displacements')

    if config['observed_gps_file'] is not None:
      pos_geo,disp,sigma = slippy.io.read_gps_data(config['observed_gps_file'])
      bm = slippy.bm.create_default_basemap(pos_geo[:,0],pos_geo[:,1],resolution='i')
      pos_cart = slippy.bm.geodetic_to_cartesian(pos_geo,bm)
      
      bm.drawstates(ax=ax)
      bm.drawcountries(ax=ax)
      bm.drawcoastlines(ax=ax)
      draw_grid(bm,ax=ax,dashes=[3,3],spacing=1.0)
      q = slippy.quiver.quiver(pos_cart[:,0],pos_cart[:,1],disp[:,0],disp[:,1],
                               sigma=(sigma[:,0],sigma[:,1],0.0*sigma[:,0]),
                               scale=QUIVER_SCALE,color='k')
      ax.quiverkey(q,QUIVER_KEY_POS_X,QUIVER_KEY_POS_Y,QUIVER_KEY_LENGTH,str(QUIVER_KEY_LENGTH) + ' [m]')
      key_drawn = True
      
      if config['slip_output_file'] is not None:
        pos_cart = slippy.bm.geodetic_to_cartesian(patch_pos_geo,bm)
        patches = [slippy.patch.Patch(p,l,w,s,d) for p,l,w,s,d in zip(pos_cart,
                                                                      length,width,
                                                                      strike,dip)]
        slippy.patch.draw_patches(patches,facecolor=(0.8,0.8,0.8),ax=ax,edgecolor=(0.8,0.8,0.8),zorder=0)
        segment_drawn = True  
      
    if config['predicted_gps_file'] is not None:
      pos_geo,disp,sigma = slippy.io.read_gps_data(config['predicted_gps_file'])
      if bm is None:
        bm = slippy.bm.create_default_basemap(pos_geo[:,0],pos_geo[:,1],resolution='i')
      pos_cart = slippy.bm.geodetic_to_cartesian(pos_geo,bm)
      
      bm.drawstates(ax=ax)
      bm.drawcountries(ax=ax)
      bm.drawcoastlines(ax=ax)
      draw_grid(bm,ax=ax,dashes=[3,3],spacing=1.0)
      q = slippy.quiver.quiver(pos_cart[:,0],pos_cart[:,1],disp[:,0],disp[:,1],
                               sigma=(sigma[:,0],sigma[:,1],0.0*sigma[:,0]),
                               scale=QUIVER_SCALE,color='b')
      if not key_drawn:
        ax.quiverkey(q,QUIVER_KEY_POS_X,QUIVER_KEY_POS_Y,QUIVER_KEY_LENGTH,str(QUIVER_KEY_LENGTH) + ' [m]')
        key_drawn = True

      if (config['slip_output_file'] is not None) & (not segment_drawn):
        pos_cart = slippy.bm.geodetic_to_cartesian(patch_pos_geo,bm)
        patches = [slippy.patch.Patch(p,l,w,s,d) for p,l,w,s,d in zip(pos_cart,
                                                                      length,width,
                                                                      strike,dip)]
        slippy.patch.draw_patches(patches,facecolor=(0.8,0.8,0.8),ax=ax,edgecolor=(0.8,0.8,0.8),zorder=0)
        segment_drawn = True  

    fig.savefig('gps.jpg');    

### NEW FIGURE
bm = None
if (config['observed_insar_file'] is not None) | (config['predicted_insar_file'] is not None):
  fig,ax = plt.subplots()
  ax.set_title('InSAR displacements')

  if config['observed_insar_file'] is not None:
    pos_geo,disp,sigma,basis = slippy.io.read_insar_data(config['observed_insar_file'])
    if bm is None:
      bm = slippy.bm.create_default_basemap(pos_geo[:,0],pos_geo[:,1],resolution='i')

    pos_cart = slippy.bm.geodetic_to_cartesian(pos_geo,bm)

    bm.drawstates(ax=ax)
    bm.drawcountries(ax=ax)
    bm.drawcoastlines(ax=ax)
    draw_grid(bm,ax=ax,dashes=[3,3],spacing=1.0)
    ax.scatter(pos_cart[:,0],pos_cart[:,1],c=disp,s=200,zorder=1)

  if config['predicted_insar_file'] is not None:
    pos_geo,disp,sigma,basis = slippy.io.read_insar_data(config['predicted_insar_file'])
    if bm is None:
      bm = slippy.bm.create_default_basemap(pos_geo[:,0],pos_geo[:,1],resolution='i')

    pos_cart = slippy.bm.geodetic_to_cartesian(pos_geo,bm)
    bm.drawstates(ax=ax)
    bm.drawcountries(ax=ax)
    bm.drawcoastlines(ax=ax)
    draw_grid(bm,ax=ax,dashes=[3,3],spacing=1.0)
    ax.scatter(pos_cart[:,0],pos_cart[:,1],c=disp,s=50,zorder=2)
  fig.savefig('insar.jpg');


plt.show()
